\documentclass[a4paper,11pt,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[babel=true]{microtype}
\usepackage[portuguese]{babel}
\usepackage[pdftex]{hyperref}
\usepackage{graphicx}
\usepackage{eurosym}
\usepackage{scrextend}
\usepackage{hyphenat}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{float}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  tabsize=2,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{blue},
  commentstyle=\itshape\color{gray},
  identifierstyle=\color{black},
  stringstyle=\color{OliveGreen},
}

\lstdefinestyle{customcwithlines}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  numbers=left,
  tabsize=2,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{blue},
  commentstyle=\itshape\color{gray},
  identifierstyle=\color{black},
  stringstyle=\color{OliveGreen},
}

\title{\huge \textbf{Protocolo de Ligação de Dados\\[1cm] \Large Relatório\\[0.7cm]
\includegraphics{res/logo.png}\\[0.7cm] \large Redes de Computadores\\[0.25cm] \small $3^o$ ano\\[0.05cm]Mestrado Integrado em Engenharia Informática e
Computação\\[1cm]}\normalsize Turma 4}

\author{Carolina Moreira\\Daniel Fazeres\\José Peixoto \and 201303494\\201502846\\200603103 \and  up201303494@fe.up.pt\\up201502846@fe.up.pt\\ei12134@fe.up.pt}

\begin{document}
\maketitle

\newpage
\tableofcontents
\newpage

\abstract
\iffalse dois parágrafos: um sobre o contexto do trabalho; outro sobre as principais conclusões do relatório \fi

No âmbito da unidade curricular de Redes de Computadores, foi-nos proposto o desenvolvimento de uma aplicação que testasse um protocolo de ligação de dados criado de raiz, transferindo um ficheiro recorrendo à porta de série $RS-232$. O trabalho permitiu praticar conceitos teóricos no desenho de um protocolo de ligação de dados como o sincronismo e delimitação de tramas, controlo de erros, controlo de fluxo recurso a mecanismos de transparência de dados na transmissão assíncrona.

Findo o projeto, notou-se a importância dos mecanismos que asseguram tolerância a falhas fornecidos pela camada de ligação de dados, uma vez que a camada física não é realmente fiável.

\section{Introdução}
\iffalse(indicação dos objectivos do trabalho e do relatório; descrição da lógica do relatório com indicações sobre o tipo de informação que poderá ser encontrada em cada uma secções seguintes) \fi
O objetivo do trabalho realizado nas aulas laboratoriais da disciplina de Redes de Computadores é a implementação de um protocolo de ligação de dados que permita praticar conhecimentos acerca de transmissões de dados entre computadores, programando em baixo nível as características comuns a este tipos de protocolos como a transparência na transmissão de dados de forma assíncrona e organização da informação sob a forma de tramas.

Este relatório pretende explicar o projeto final descrevendo a sua estrutura e os principais casos de uso. 

\section{Arquitetura}
\iffalse (blocos funcionais e interfaces) \fi
O projeto está organizado em duas camadas principais: a camada de aplicação e a camada de ligação de dados. As camadas respeitam o princípio de independência uma vez que cada uma apenas se responsabiliza/conhece um tipo de tarefa específica, no caso da camada de aplicação, de mais alto nível, lida-se com a interação de ficheiros e pacotes de dados e no caso da ligação de dados são feitas as tarefas de mais baixo nível relacionadas com o processamento de tramas e a interação com a porta de série.

A camada de aplicação está implementada nos ficheiros \texttt{netlink.c}, \texttt{file.c} e \texttt{packets.c}.

A camada de ligação de dados está implementada nos ficheiros \texttt{serial\_port.c} \texttt{data\_link\_io.c} e \texttt{data\_link.c}.

\section{Casos de uso principais}
\iffalse (identificação; sequências de chamada de funções) \fi
A utilização do programa divide-se em dois propósitos distintos: envio ou receção de um ficheiro. A fase de tratamento dos parâmetros opcionais passados pela linha de comandos é comum em ambos os casos e engloba a chamada de funções como: \texttt{parse\_args}, \texttt{parse\_serial\_port\_arg}, \texttt{parse\_flags} e chamadas opcionais a outras funções consoante os parâmetros passados. 

\subsection*{Envio de ficheiro}
Após a interpretação dos parâmetros opcionais e a leitura do ficheiro, o programa invoca a função \texttt{send\_file} da camada de aplicação para o envio de um ficheiro que por sua vez pede à camada de ligação de dados que estabeleça uma ligação pela porta de série na chamada à função \texttt{transmitter\_connect} e transmita dados através da função \texttt{transmitter\_write} e termine a ligação com a chamada \texttt{disconnect}.

A chamada \texttt{transmitter\_connect} da camada da ligação de dados abre a porta de série envia a trama SET e recebe a trama UA. No envio de tramas que requerem confimação de receção é usada a função \texttt{f\_send\_acknowledged\_frame}. Antes da chamada à função \texttt{transmitter\_write}, o programa organiza a informação a enviar sob a forma de pacotes de dados nas funções \texttt{send\_control\_packet} ou \texttt{send\_data\_packets}.

\subsection*{Receção de ficheiro}
Após a interpretação dos parâmetros opcionais e a leitura do ficheiro, o programa invoca a função \texttt{receive\_file} da camada de aplicação para a receção de um ficheiro que por sua vez pede à camada de ligação de dados que estabeleça uma ligação pela porta de série com a chamada à função \texttt{receiver\_listen} e receba pacotes de dados através da função \texttt{receiver\_read} e termine a ligação com a chamada \texttt{disconnect}.

A chamada \texttt{receiver\_listen} da camada da ligação de dados abre a porta de série e espera pela receção de uma trama SET enviando em seguida a confirmação de receção com a função \texttt{f\_send\_frame}. Na camada de ligação de dados é usada a função \texttt{f\_receive\_frame} na receção de tramas. Após a receção de um pacote de dados através da função \texttt{llread}, o programa descodifica os dados recebidos nas funções \texttt{parse\_control\_packet} ou \texttt{parse\_data\_packet} caso se espere receber um pacote de controlo ou de dados respectivamente.

\section{Protocolo de ligação lógica}
\iffalse (identificação dos principais aspectos funcionais; descrição da estratégia de implementação destes aspectos com apresentação de extratos de código) \fi
A camada de ligação lógica é responsável pelo envio de informação através da porta de série. Para tal, uma série de mecanismos são necessários para assegurar a transmissão com sucesso dos dados. Os dados são encapsulados em tramas com numeração e a delimitação das tramas é feita por uma sequêncial especial de oito bits.
É também assegurada a transparência dos dados pela técnica de byte stuffing.

A proteção da integridade dos dados é feita  pelo uso de um código detetor de erros, no caso das tramas S e U pelo $BCC1$ e nas tramas I existe um segundo código, o $BCC2$, que verifica a integridade do campo de dados.

\subsection*{Delimitação e envio de uma trama}

\begin{lstlisting}[style=customc]
Return_e f_send_frame(const int fd, const struct frame frame)
{
	byte *bp = g_buffer;

	*bp++ = FLAG;

	// write header
	*bp++ = frame.address;
	*bp++ = frame.control;
	*bp++ = frame.address ^ frame.control; // bcc

	// copy data
	if (frame.size > LL_MAX_PAYLOAD_UNSTUFFED) {
		return ERROR_CODE;

	} else if (frame.size > 0) { // frame might be 0 if it is supervision
		bp = copy_and_stuff_bytes(bp, frame.data, frame.size);
	}

	*bp++ = FLAG;

	if (serial_port_write(fd, g_buffer, bp - g_buffer) < 0) {
		return ERROR_CODE;
	}
	++g_sent_frame_counter;

	return SUCCESS_CODE;
}
\end{lstlisting}

\subsection*{Verificação da integridade uma trama recebida}
\begin{lstlisting}[style=customc]
static Return_e parse_frame_from_array(struct frame* frame, byte *a)
{
	if (*a++ != FLAG) {
		return ERROR_CODE;
	}
	for (int i = 0; i <= 2; i++) { // the next fields should not have a FLAG
		if (a[i] == FLAG) {
			return BADFRAME_CODE;
		}
	}

	frame->address = *a++;
	frame->control = *a++;
	const byte header_bcc = *a++;
	if (header_bcc != (frame->address ^ frame->control)) {
		++g_header_bcc_error_counter;
		return BADFRAME_CODE;
	}
	frame->size = 0;

	/* Supervision frame */
	if (*a == FLAG) {
		return SUCCESS_CODE;
	}

	if (*(a + 1) == FLAG) {
		return BADFRAME_CODE;
	}

	/* Data frame */
	byte data_bcc = 0;
	size_t num_bytes = 0;
	while (1) {
		if (num_bytes > LL_MAX_PAYLOAD_STUFFED) {
			return BADFRAME_CODE;
		}
		if (frame->size > frame->max_data_size) {
			return BADFRAME_CODE;
		}

		byte c;
		if (a[num_bytes] == BS_ESC) {
			fprintf(stderr, "----\n");
			// remove byte stuffing
			++num_bytes;
			c = BS_OCT ^ a[num_bytes];
		} else {
			c = a[num_bytes];
		}
        ++num_bytes;
        frame->data[frame->size++] = c;
        fprintf(stderr, "%x\n", c);

		/*
		 * Stop loop condition.
		 */
		if (a[num_bytes] == FLAG) {
			if (frame->data[frame->size-1] != data_bcc) {
				++g_data_bcc_error_counter;
				return BADFRAME_CODE;
			}
			return SUCCESS_CODE;
		} else {
            data_bcc ^= c;
            fprintf(stderr,"c = %x, bcc = %x\n",c,data_bcc);
        }

	}
}
\end{lstlisting}

\section{Protocolo de aplicação}
\iffalse (identificação dos principais aspectos funcionais; descrição da estratégia de implementação destes aspectos com apresentação de extractos de código) \fi

A camada de aplicação é responsável pela leitura/escrita dos dados do ficheiro a enviar/receber. Do lado do emissor, procede-se à segmentação do ficheiro em pacotes de dados que vão sendo numerados e enviados para a camada de ligação de dados, por forma a serem encaixados em tramas de informação e posteriormente enviados através da porta de série. Do lado do receptor, é feita a compilação e escritura dos dados recebidos num ficheiro em disco nomeado de acordo com a informação recebida nos pacotes de controlo. Quer no emissor quer no receptor, recorre-se à codificação das etapas sob a forma de máquinas de estado.

\subsection{Envio de um ficheiro}
A camada de aplicação pode interpretar os argumentos opcionais passados através da interface de linha de comandos para ler do disco um ficheiro para uma estrutura de dados que armazena os dados, o nome e o tamanho do ficheiro. Opcionalmente, só os dados de um ficheiro serão lidos do \texttt{stdin} para a estrutura de dados referida e será atribuído um nome de ficheiro predefinido.

\begin{lstlisting}[style=customc]
struct file {
    const char* name;
    size_t size;
    char* data;
};
\end{lstlisting}

Após a leitura do ficheiro, a camada de aplicação entra numa máquina de estados com quatro estados ordenados: abertura de ligação, envio de pacote de controlo inicial, envio de pacotes de dados, envio de pacote de controlo final e fecho da ligação.

\subsubsection*{Método usado na abertura de ligação}

\begin{lstlisting}[style=customc]
int llopen(char *port, int transmitter);
\end{lstlisting}

\subsubsection*{Método usado para o envio de pacotes de controlo inicial e final}
\begin{lstlisting}[style=customc]
int send_control_packet(struct connection* connection, struct file *file,
        byte control_field);
\end{lstlisting}

\subsubsection*{Método usado para o envio de pacote de dados}
\begin{lstlisting}[style=customc]
int send_data_packets(struct connection* connection, struct file* file,
        size_t* num_data_bytes_sent, size_t* sequence_number);
\end{lstlisting}

\subsubsection*{Método usado para o envio dos pacotes para a camada de ligação de dados}
\begin{lstlisting}[style=customc]
int transmitter_write(struct connection* conn, byte* data_packet, size_t size);
\end{lstlisting}

\subsubsection*{Método usado no fecho da ligação}
\begin{lstlisting}[style=customc]
int llclose(const int fd);
\end{lstlisting}

\subsection{Receção de um ficheiro}

Após a interpretação dos parâmetros passados pela linha de comandos que indicam ao programa para receber um ficheiro, a camada de aplicação entra numa máquina de estados com quatro estados ordenados: abertura de ligação, receção de pacote de controlo inicial, receção de pacotes de dados e fecho da ligação. Após o estabelecimento de uma ligação com sucesso, o programa fica à espera da receção de um pacote de controlo com os dados relativos ao tamanho e nome do ficheiro. Posteriormente, inicia-se o processo de receção dos pacotes de dados com a informação contida no ficheiro até que se receba um pacote de controlo final, sinalizando o fim da receção do ficheiro.

\subsubsection*{Método usado para receber o pacote de controlo inicial}
\begin{lstlisting}[style=customc]
int receive_start_control_packet(const int fd,
		char **file_name, size_t *file_size)
\end{lstlisting}

\subsubsection*{Método usado para descodificar um pacote de controlo}
\begin{lstlisting}[style=customc]
int parse_control_packet(const int control_packet_length,
		byte *control_packet, char **file_name,
		size_t *file_size)
\end{lstlisting}

\subsubsection*{Método usado para receber pacotes de dados e escrever em disco}
\begin{lstlisting}[style=customc]
int receive_data_packets(const int fd, char* file_name, 
		size_t file_size, int attempts_left)
\end{lstlisting}

\subsubsection*{Método usado para descodificar um pacote pacote de dados}
\begin{lstlisting}[style=customc]
int parse_data_packet(const int data_packet_length,
		byte *data_packet, char **data,
		size_t* sequence_number)
\end{lstlisting}

\subsubsection*{Método usado para descodificar um pacote pacote de dados}
\begin{lstlisting}[style=customc]
int parse_data_packet(const int data_packet_length,
		byte *data_packet, char **data,
		size_t* sequence_number)
\end{lstlisting}

\section{Validação}
\iffalse (descrição dos testes efectuados com apresentação quantificada dos resultados, se possível) \fi
O projeto inclui testes unicamente a camada de ligação de dados nos ficheiros \texttt{data\_link\_test.c} e \texttt{serial\_port\_test}. No caso da porta de série, são feitos pequenos testes com a validação dos outputs dado um determinado input numa chamada directa das funções read e write à camada lógica. 

No caso da ligação de dados é feito um teste ao nível do sistema de tramas incluíndo os códigos de verificação de integridade e byte stuffing.

\section{Elementos de valorização}
\iffalse (identificação dos elementos de valorização implementados; descrição da estratégia de implementação com apresentação de pequenos extratos de código) \fi

\subsection{Selecção de parâmetros pelo utilizador}
Quando o programa é invocado pela linha de comandos de forma errónea ou sem quaisquer parâmetros adicionais, são mostrados os argumentos opcionais disponíveis que permitem configurar a execução do programa, nomeadamente o modo de operação (\texttt{receiver} ou \texttt{transmitter}), leitura do ficheiro a enviar do disco ou proveniente de dados redirecionados do \texttt{stdin}, selecção da baudrate, determinação do tamanho máximo de bytes de dados enviados em cada frame e do número de tentativas na recuperação de erros. 

\subsection{Implementação de REJ}
Quando ocorrem erros no processamento de tramas recebidas na camada de ligação de dados, é enviada de forma preemptiva ao \texttt{timeout} uma trama com confirmação negativa (\texttt{REJ}) que permite a retransmissão da trama de informação.

\begin{lstlisting}[style=customc]
else if (ret == BADFRAME_CODE) {
	/*
	* Send 'bad frame' acknowledgment.
	*/
	byte c_out = data_reply_byte(conn->frame_number, FALSE);
	if (f_send_frame(conn->fd, FRAME(c_out)) != SUCCESS_CODE)
		break;
}
\end{lstlisting}

\subsection{Verificação da integridade dos dados pela Aplicação}
Após receção com sucesso do primeiro pacote de controlo pela camada de aplicação, é armazenado o tamanho expectável em bytes do ficheiro a receber, comparando-o no fim da sessão com o valor real de bytes dados recebidos. São também guardados os números de pacotes de dados perdidos e duplicados.

\begin{lstlisting}[style=customc]
void receiver_stats()
{
    fprintf(stdout, "Receiver statistics\n");
    fprintf(stdout, "\treceived file bytes/file bytes:%zu/%zu\n",
            received_file_bytes, real_file_bytes);
    fprintf(stdout, "\tlost packets:%zu\n", lost_packets);
    fprintf(stdout, "\tduplicated packets:%zu\n", duplicated_packets);
}
\end{lstlisting}

\section{Conclusões}
\iffalse (síntese da informação apresentada nas secções anteriores; reflexão sobre os objectivos de aprendizagem alcançados) \fi

O projeto pode ser sumariamente descrito pelo seu principal propósito que é o desenvolvimento de um protocolo de ligação de dados e o seu teste pelo sucesso na transferência de ficheiros entre dois computadores. 

\begin{thebibliography}{9}
\bibitem{lamport93}
  Andrew S. Tanenbaum,
  David J. Wetherall,
  \emph{Computer Networks},
  Prentice Hall, 
  5th edition,
  2011.
\end{thebibliography}

\appendix
\section{Código fonte}
\subsection{Camada de aplicação}
\subsubsection*{netlink.c}
\begin{lstlisting}[style=customcwithlines]
void receiver_stats()
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>

#include "packets.h"
#include "file.h"
#include "netlink.h"
#include "serial_port.h"

struct file file_to_send;
int max_retries = 3;

void help(char **argv)
{
	fprintf(stderr, "Usage: %s [OPTIONS] <serial port>\n", argv[0]);
	fprintf(stderr, "\n Program options:\n");
	fprintf(stderr, "  -t <FILEPATH>\t\ttransmit file over the serial port\n");
	fprintf(stderr, "  -i\t\t\ttransmit data read from stdin\n");
	fprintf(stderr, "  -b <BAUDRATE>\t\tbaudrate of the serial port\n");
	fprintf(stderr,
			"  -p <DATASIZE>\t\tmaximum bytes of data transfered each frame\n");
	fprintf(stderr, "  -r <RETRY>\t\tnumber of retry attempts\n");
}

int parse_serial_port_arg(int index, char **argv)
{
	if ((strcmp("/dev/ttyS0", argv[index]) != 0)
			&& (strcmp("/dev/ttyS1", argv[index]) != 0)
			&& (strcmp("/dev/ttyS4", argv[index]) != 0)) {
		fprintf(stderr, "Error: bad serial port value\n");
		return -1;
	}

	return index;
}

int parse_baudrate_arg(int baurdate_index, char **argv)
{
	if (strcmp("B50", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B50;
		return 0;
	} else if (strcmp("B75", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B75;
		return 0;
	} else if (strcmp("B110", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B110;
		return 0;
	} else if (strcmp("B134", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B134;
		return 0;
	} else if (strcmp("B150", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B150;
		return 0;
	} else if (strcmp("B200", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B200;
		return 0;
	} else if (strcmp("B300", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B300;
		return 0;
	} else if (strcmp("B600", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B600;
		return 0;
	} else if (strcmp("B1200", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B1200;
		return 0;
	} else if (strcmp("B1800", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B1800;
		return 0;
	} else if (strcmp("B2400", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B2400;
		return 0;
	} else if (strcmp("B4800", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B4800;
		return 0;
	} else if (strcmp("B9600", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B9600;
		return 0;
	} else if (strcmp("B19200", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B19200;
		return 0;
	} else if (strcmp("B38400", argv[baurdate_index]) == 0) {
		serial_port_baudrate = B38400;
		return 0;
	}
	fprintf(stderr, "Error: bad serial port baudrate value\n");
	fprintf(stderr,
			"Valid baudrates: B110, B134, B150, B200, B300, B600, B1200, B1800, B2400, B4800, B9600, B19200, B38400\n");
	return -1;
}

void parse_max_packet_size(int packet_size_index, char **argv)
{
	int val = atoi(argv[packet_size_index]);
	if (val > FRAME_SIZE || val < 0)
		max_data_transfer = FRAME_SIZE;
	else
		max_data_transfer = val;

#ifdef NETLINK_DEBUG_MODE
	fprintf(stderr,"\nparse_max_packet_size:\n");
	fprintf(stderr,"  max_packet_size=%d\n", max_data_transfer);
#endif
}

void parse_max_retries(int packet_size_index, char **argv)
{
	int val = atoi(argv[packet_size_index]);
	if (val <= 0)
		max_retries = 4;
	else
		max_retries = 1 + val;

#ifdef NETLINK_DEBUG_MODE
	fprintf(stderr,"\nmax_retries:\n");
	fprintf(stderr,"  max_retries=%d\n", max_retries);
#endif
}

int parse_flags(int* t_index, int* i_index, int* b_index, int* p_index,
		int* r_index, int argc, char **argv)
{
	for (size_t i = 0; i < (argc - 1); i++) {
		if ((strcmp("-t", argv[i]) == 0)) {
			*t_index = i;
		} else if ((strcmp("-i", argv[i]) == 0)) {
			*i_index = i;
		} else if ((strcmp("-b", argv[i]) == 0)) {
			*b_index = i;
		} else if ((strcmp("-p", argv[i]) == 0)) {
			*p_index = i;
		} else if ((strcmp("-r", argv[i]) == 0)) {
			*r_index = i;
		} else if ((argv[i][0] == '-')) {
			return -1;
		}
	}
#ifdef NETLINK_DEBUG_MODE
	fprintf(stderr,"\nparse_flags(): flag indexes\n");
	fprintf(stderr,"  -t=%d\n  -i=%d\n  -b=%d\n  -p=%d\n  -r=%d\n", *t_index, *i_index, *b_index,
			*p_index, *r_index);
#endif
	return 0;
}

int parse_args(int argc, char **argv, int *is_transmitter)
{

#ifdef NETLINK_DEBUG_MODE
	fprintf(stderr,"\nparse_args(): received arguments\n");
	fprintf(stderr,"  argc=%d\n  argv=%s\n", argc, *argv);
#endif

	if (argc < 2) {
		return -1;
	}

	if (argc == 2)
		return parse_serial_port_arg(1, argv);

	int t_index = -1, i_index = -1, b_index = -1, p_index = -1, r_index = -1;

	if (parse_flags(&t_index, &i_index, &b_index, &p_index, &r_index, argc,
			argv)) {
		fprintf(stderr, "Error: bad flag parameter\n");
		return -1;
	}

	if (t_index > 0 && t_index < argc - 1) {
		if (read_file_from_disk(argv[t_index + 1], &file_to_send) < 0) {
			return -1;
		}
		*is_transmitter = 1;
	} else {
		if (i_index > 0 && i_index < argc - 1) {
			if (read_file_from_stdin(&file_to_send) < 0) {
				return -1;
			}
			*is_transmitter = 1;
		}
	}

	if (b_index > 0 && b_index < argc - 1) {
		if (parse_baudrate_arg(b_index + 1, argv) != 0) {
			return -1;
		}
	}

	if (p_index > 0 && p_index < argc - 1) {
		parse_max_packet_size(p_index + 1, argv);
	}

	if (r_index > 0 && r_index < argc - 1) {
		parse_max_retries(r_index + 1, argv);
	}

	return parse_serial_port_arg(argc - 1, argv);
}

int main(int argc, char **argv)
{
	int port_index = -1;
	int is_transmitter = 0;

	if ((port_index = parse_args(argc, argv, &is_transmitter)) < 0) {
		help(argv);
		exit(EXIT_FAILURE);
	}

	if (is_transmitter) {
		fprintf(stderr, "transmitting %s\n", file_to_send.name);
		return send_file(argv[port_index], &file_to_send, max_retries);
	} else {
		fprintf(stderr, "receiving file\n");
#ifdef NETLINK_DEBUG_MODE
		fprintf(stderr, "\tserial_port_baudrate:%d\n", serial_port_baudrate);
		fprintf(stderr, "\tis_transmitter:%d\n", is_transmitter);
#endif
		return receive_file(argv[port_index], max_retries);
	}
}
\end{lstlisting}

\subsubsection*{file.c}
\begin{lstlisting}[style=customcwithlines]
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <libgen.h>
#include <limits.h>
#include "file.h"

int read_file_from_stdin(struct file *f)
{
	char *buffer;
	if ((buffer = malloc(sizeof(char) * INT_MAX)) == NULL ) {
		perror("read_file_from_stdin() buffer malloc error");
		return -1;
	}

	size_t size = 0;

	if ((size = fread(buffer, sizeof(char), INT_MAX, stdin)) < 0) {
		fprintf(stderr, "ERROR: reading from the stdin.\n");
		return -1;
	}

#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, "read_file_from_stdin()\n\tname=%s\n\tsize=%zu\n\tdata=%s\n", "stdin.out", size,
			buffer);
#endif

	f->name = "output";
	f->size = size;
	f->data = buffer;

	return 0;
}

int read_file_from_disk(char *name, struct file *f)
{
	size_t length;
	FILE *file = fopen(name, "r");

	if (file != NULL ) {
		fseek(file, 0L, SEEK_END);
		length = ftell(file);
		char *buffer = malloc(sizeof(char) * length);
		if (buffer != NULL ) {
			fseek(file, 0, SEEK_SET);
			fread(buffer, 1, length, file);
			fclose(file);
			f->name = basename(name);
			f->size = length;
			f->data = buffer;
			return 0;
		}
	}

	fprintf(stderr, "Error: file %s is NULL.\n", name);
	return -1;
}
\end{lstlisting}

\subsubsection*{packets.c}
\begin{lstlisting}[style=customcwithlines]
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>

#include "data_link.h"
#include "byte.h"
#include "packets.h"

int max_data_transfer = FRAME_SIZE;

size_t real_file_bytes = 0;
size_t received_file_bytes = 0;
size_t lost_packets = 0;
size_t duplicated_packets = 0;

struct connection g_connections[MAX_FD];

int send_file(char *port, struct file *file, int max_send_attempts)
{
	fprintf(stderr, "send_file\n");
	int fd = 0;
	struct connection* connection;
	int attempts_left = max_send_attempts;
	int state = SND_OPEN_CONNECTION;
	size_t num_data_bytes_sent = 0;
	size_t sequence_number = 0;

	while (attempts_left) {
		switch (state) {
		case SND_OPEN_CONNECTION:
			fprintf(stderr, "open connection\n");
			if ((fd = llopen(port, 1)) > 0) {
				connection = &g_connections[fd];
				attempts_left = max_send_attempts;
				state = SND_START_CONTROL_PACKET;
			} else {
#ifdef APPLICATION_LAYER_DEBUG_MODE
				fprintf(stderr, "llopen() returned an error code\n");
				fprintf(stderr, "\t%d attempts left\n", attempts_left - 1);
#endif
				state = SND_OPEN_CONNECTION;
				retry(&attempts_left);
			}
			break;
		case SND_START_CONTROL_PACKET:
			fprintf(stderr, "start control packet\n");
			if (send_control_packet(connection, file, control_field_start)
					< 0) {
#ifdef APPLICATION_LAYER_DEBUG_MODE
				fprintf(stderr,
						"start of transmission send_start_control_packet() returned an error code\n");
				fprintf(stderr, "\t%d attempts left\n", attempts_left - 1);
#endif
				retry(&attempts_left);
			} else {
				attempts_left = max_send_attempts;
				state = SND_DATA_PACKETS;
			}
			break;
		case SND_DATA_PACKETS:
			fprintf(stderr, "send data packets\n");
			if (send_data_packets(connection, file, &num_data_bytes_sent,
					&sequence_number) < 0) {
#ifdef APPLICATION_LAYER_DEBUG_MODE
				fprintf(stderr, "send_data_packets() returned an error code\n");
				fprintf(stderr, "\t%d attempts left\n", attempts_left - 1);
#endif
				retry(&attempts_left);
			} else {
				attempts_left = max_send_attempts;
				state = SND_CLOSE_CONTROL_PACKET;
			}
			break;
		case SND_CLOSE_CONTROL_PACKET:
			if (send_control_packet(connection, file, control_field_end) < 0) {
#ifdef APPLICATION_LAYER_DEBUG_MODE
				fprintf(stderr,
						"end of transmission send_control_packet() returned an error code");
				fprintf(stderr, "\t%d attempts left\n", attempts_left - 1);
#endif
				retry(&attempts_left);
			} else {
				attempts_left = max_send_attempts;
				state = SND_CLOSE_CONNECTION;
			}
			break;
		case SND_CLOSE_CONNECTION:
			if (llclose(fd) == 0) {
				return 0;
			} else {
				state = RCV_CLOSE_CONNECTION;
				retry(&attempts_left);
			}
			break;
		default:
			return -1;
			break;
		}
	}
	return -1;
}

int send_control_packet(struct connection* connection, struct file *file,
		byte control_field)
{
	// 5 bytes plus 2 specific data type sizes (value fields)
	size_t control_packet_size = (5 + sizeof(size_t)
			+ ((strlen(file->name) + 1) * sizeof(char)));
	if (control_packet_size > connection->packet_size) {
		fprintf(stderr, "control_packet_size (%zu) > (%zu) allowed packet size",
				control_packet_size, connection->packet_size);
		return -1;
	}

#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, "send_control_packet()\n");
	fprintf(stderr, "\tcontrol_field=%d\n", control_field);
	fprintf(stderr, "\tcontrol_packet_size=%zu\n", control_packet_size);
	fprintf(stderr, "\tpacket_size=%zu\n", (connection->packet_size));
	fprintf(stderr, "\tl1=%zu\n", sizeof(size_t));
	fprintf(stderr, "\tfile_size=%zu\n", file->size);
	fprintf(stderr, "\tname=%s\n", file->name);
	fprintf(stderr, "\tl2=%zu\n", strlen(file->name));
#endif

	byte* control_packet;
	if ((control_packet = malloc(control_packet_size * sizeof(byte))) == NULL ) {
		perror("send_control_packet() control_packet malloc error");
		return -1;
	}
	control_packet[control_field_index] = control_field;

	// TLV (file size)
	size_t v1_length = sizeof(size_t);
	control_packet[control_packet_t1_index] = control_packet_tlv_type_filesize;
	control_packet[control_packet_l1_index] = v1_length;

#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, "\tv1_length=%zu\n", v1_length);
#endif

	memcpy(control_packet + control_packet_v1_index, &(file->size), v1_length);

	// TLV (file name)
	size_t v2_length = strlen(file->name);
	size_t control_packet_t2_index = 4 + v1_length;
	size_t control_packet_l2_index = control_packet_t2_index + 1;
	size_t control_packet_v2_index = control_packet_l2_index + 1;

	control_packet[control_packet_t2_index] = control_packet_tlv_type_name;
	control_packet[control_packet_l2_index] = v2_length;
	memcpy(control_packet + control_packet_v2_index, (byte*) file->name,
			v2_length);
//	control_packet[control_packet_l2_index + v2_length] = '\0';

	if (transmitter_write(connection, control_packet, control_packet_size)
			< 0) {
		free(control_packet);
		return -1;
	}

	free(control_packet);
	return 0;
}

int send_data_packets(struct connection* connection, struct file* file,
		size_t* num_data_bytes_sent, size_t* sequence_number)
{
	fprintf(stderr, "send_data_packets\n");
	byte* file_data_pointer = (byte*) file->data;
	const byte* eof_data_pointer = ((byte*) file->data
			+ file->size * sizeof(char));

	for (size_t i = 0; i < *num_data_bytes_sent; i++)
		file_data_pointer++;

	while (file_data_pointer < eof_data_pointer) {
		fprintf(stderr, "while (file_data_pointer < eof_data_pointer)\n");
		size_t max_data_size = connection->packet_size
				- data_packet_header_size;
		if (max_data_transfer > 0 && max_data_transfer < max_data_size) {
			max_data_size = max_data_transfer;
		}

		size_t remaining_data_bytes = file->size - *num_data_bytes_sent;
		size_t remainder = remaining_data_bytes % (max_data_size);
		size_t data_bytes_to_send =
				remainder == 0 ? (max_data_size) : remainder;

		size_t data_packet_size = data_bytes_to_send + data_packet_header_size;

		byte* data_packet;
		if ((data_packet = malloc(data_packet_size * sizeof(byte))) == NULL ) {
			perror("send_control_packet() data_packet malloc error");
			return -1;
		}

		data_packet[control_field_index] = control_field_data;
		data_packet[data_packet_sequence_number_index] = (*sequence_number)
				% sequence_number_modulus;
		(*sequence_number)++;
		data_packet[data_packet_l2_index] = (data_bytes_to_send / 256);
		data_packet[data_packet_l1_index] = (data_bytes_to_send % 256);
		//fprintf(stderr,"sending packet %zu\n",data_packet_sequence_number_index);
		fprintf(stderr, "sequence_number: %ld\n", *sequence_number);

		for (size_t i = 0;
				file_data_pointer < eof_data_pointer && i < data_bytes_to_send;
				i++) {
			data_packet[i + data_packet_header_size] =
					(byte) file->data[*num_data_bytes_sent];

			file_data_pointer++;
			(*num_data_bytes_sent)++;
		}

		if (transmitter_write(connection, data_packet, data_packet_size) < 0) {
			free(data_packet);
			fprintf(stderr, "transmitter write returned negative\n");
			return -1;
		}

		free(data_packet);
	}
	return 0;
}

int receive_file(char *port, int max_receive_attempts)
{
	int fd = 0;
	int attempts_left = max_receive_attempts;
	char *file_name;
	size_t file_size;
	int state = RCV_OPEN_CONNECTION;

	while (attempts_left) {
		switch (state) {
		case RCV_OPEN_CONNECTION:
			fprintf(stderr, "opening connection..\n");
			if ((fd = llopen(port, 0)) > 0) {
				state = RCV_START_CONTROL_PACKET;
				attempts_left = max_receive_attempts;
			} else {
				retry(&attempts_left);
			}
			break;

		case RCV_START_CONTROL_PACKET:
			fprintf(stderr, "expecting control packet\n");
			if (receive_start_control_packet(fd, &file_name, &file_size) < 0) {
#ifdef APPLICATION_LAYER_DEBUG_MODE
				fprintf(stderr,
						"receive_start_control_packet() returned an error code\n");
				fprintf(stderr, "\t%d attempts left\n", attempts_left - 1);
#endif
				retry(&attempts_left);
				break;
			} else {
				state = RCV_DATA_PACKETS;
				attempts_left = max_receive_attempts;
				real_file_bytes = file_size;
			}
			break;

		case RCV_DATA_PACKETS:
			fprintf(stderr, "expecting data packet\n");
			if (receive_data_packets(fd, file_name, file_size, attempts_left)
					< 0) {
				receiver_stats();
				return -1;
				break;
			} else {
				state = RCV_CLOSE_CONNECTION;
				attempts_left = max_receive_attempts;
			}
			break;

		case RCV_CLOSE_CONNECTION:
			if (llclose(fd) == 0) {
				receiver_stats();
				return 0;
			} else {
				state = RCV_CLOSE_CONNECTION;
				retry(&attempts_left);
			}
			break;
		default:
			receiver_stats();
			return -1;
		}
	}
	return -1;
}

int receive_start_control_packet(const int fd, char **file_name,
		size_t *file_size)
{
	byte *control_packet;
	int control_packet_length = 0;

	if ((control_packet_length = llread(fd, &control_packet)) < 0) {
		free(control_packet);
		return -1;
	}

	byte control_field = control_packet[control_field_index];
	if (control_field == control_field_start) {
		return parse_control_packet(control_packet_length, control_packet,
				file_name, file_size);
	}

#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, "receive_data_packet(): bad control field value\n");
#endif

	free(control_packet);
	return -1;
}

int receive_data_packets(const int fd, char* file_name, size_t file_size,
		int attempts_left)
{
	FILE* received_file = fopen(file_name, "w");
	int receive_return_value = 1;
	size_t sequence_number = 0;

#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, "receive_data_packets()\n");
	fprintf(stderr, "\tfile_name=%s\n", file_name);
	fprintf(stderr, "\tfile_size=%zu\n", file_size);
#endif

	while (receive_return_value > 0 && attempts_left > 0) {

		char *file_data;

		if ((receive_return_value = receive_data_packet(fd, &file_data,
				received_file_bytes, &sequence_number)) < 0) {
#ifdef APPLICATION_LAYER_DEBUG_MODE
			fprintf(stderr, "receive_data_packet() returned an error code\n");
			fprintf(stderr, "\t%d attempts left\n", attempts_left - 1);
#endif
			retry(&attempts_left);
			receive_return_value = 1;
		} else {
			sequence_number++;
			received_file_bytes += receive_return_value;

#ifdef APPLICATION_LAYER_DEBUG_MODE
			fprintf(stderr, "\treceive_return_value=%d\n", receive_return_value);
			fprintf(stderr, "\treceived_file_bytes=%zu\n", received_file_bytes);
#endif

			if ((fwrite(file_data, sizeof(char), receive_return_value,
					received_file)) < 0) {
				fprintf(stderr, "Error: file write error\n");
				return -1;
			}

			if (receive_return_value > 0) {
				free(file_data);
			}
		}
	}

#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr,"receive_data_packets()\n");
	fprintf(stderr,"\tfile_data_length=%zu\n", received_file_bytes);
#endif

	if (attempts_left <= 0) {
		return -1;
	}

	return fclose(received_file);
}

int parse_control_packet(const int control_packet_length, byte *control_packet,
		char **file_name, size_t *file_size)
{
// TLV (file size)
	if (control_packet[control_packet_t1_index]
			!= control_packet_tlv_type_filesize) {
		fprintf(stderr, "parse_control_packet(): bad type 1");
		return -1;
	}
	size_t v1_length = control_packet[control_packet_l1_index];

	if (v1_length != sizeof(size_t)) {
		fprintf(stderr, "parse_control_packet(): bad L1 - file size length");
		return -1;
	}

	size_t *file_size_tmp;

	if ((file_size_tmp = malloc(sizeof(size_t))) == NULL ) {
		perror("parse_control_packet() file_size_tmp malloc error");
		return -1;
	}

	memcpy(file_size_tmp, (control_packet + control_packet_v1_index),
			v1_length);
	*file_size = *file_size_tmp;

// TLV (file name)
	size_t control_packet_t2_index = control_packet_v1_index + v1_length + 1;
	size_t control_packet_l2_index = control_packet_t2_index + 1;
	size_t control_packet_v2_index = control_packet_l2_index + 1;

	byte t2 = *(control_packet + control_packet_t2_index);

	if (t2 != control_packet_tlv_type_name) {
		fprintf(stderr, "parse_control_packet(): bad type 2");
		free(file_size_tmp);
		return -1;
	}

	size_t v2_length = *(control_packet + control_packet_l2_index);

	if ((*file_name = malloc(v2_length * sizeof(char))) == NULL ) {
		perror("parse_control_packet() file_name malloc error");
		free(file_size_tmp);
		return -1;
	}

	memcpy(*file_name, (control_packet + control_packet_v2_index), v2_length);

#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, "\tl1=%zu\n", v1_length);
	fprintf(stderr, "\tfile_size=%zu\n", *file_size);
	fprintf(stderr, "\tl2=%zu\n", v2_length);
	fprintf(stderr, "\tname=%s\n", *file_name);
#endif
	free(control_packet);
	return 0;
}

int parse_data_packet(const int data_packet_length, byte *data_packet,
		char **data, size_t* sequence_number)
{
	int data_size = data_packet[data_packet_l2_index] * 256
			+ data_packet[data_packet_l1_index];
#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, "parse_data_packet()\n");
	fprintf(stderr, "\tcontrol_field=%d\n", data_packet[control_field_index]);
	fprintf(stderr, "\tsequence_number=%d\n",
			data_packet[data_packet_sequence_number_index]);
	fprintf(stderr, "\tdata_size=%d\n", data_size);
#endif

	if ((*data = malloc(sizeof(char) * data_size)) == NULL ) {
		perror("parse_data_packet() data malloc error");
		return -1;
	}

	memcpy(*data, (data_packet + data_packet_header_size * sizeof(byte)),
			data_size);

	size_t received_sequence_number =
			data_packet[data_packet_sequence_number_index];
	size_t expected_sequence_number = *sequence_number
			% sequence_number_modulus;
	if (received_sequence_number != expected_sequence_number) {
#ifdef APPLICATION_LAYER_DEBUG_MODE
		fprintf(stderr, "bad packet sequence number: (received %zu) <-> (expected %zu)\n", received_sequence_number, expected_sequence_number);
		free(data_packet);
		return -1;
#endif
		if (received_sequence_number > expected_sequence_number) {

			while (*sequence_number % sequence_number_modulus
					!= received_sequence_number) {
				(*sequence_number)++;
				lost_packets++;
			}
		} else {
			duplicated_packets++;
			*sequence_number = expected_sequence_number;
		}
		//		free(data_packet);
//		free(*data);
//		return -1;
	}
	free(data_packet);
	return data_size;
}

int llread(const int fd, byte **packet)
{
	struct connection* c = &g_connections[fd];

// maximum size of a packet
	size_t packet_size = c->packet_size * sizeof(byte);

	if ((*packet = malloc(packet_size)) == NULL ) {
		perror("llread() packet malloc error");
		return -1;
	}

	int packet_length = 0;
	if (c->is_active) {
		if ((packet_length = receiver_read(c, *packet, packet_size,
				NUM_FRAMES_PER_CALL)) < 0) {
			fprintf(stderr, "llread(): error in receiver_read()\n");
			free(*packet);
			return -1;
		}
	} else {
		fprintf(stderr, "llread(): connection is not active\n");
		free(*packet);
		return -1;
	}

	return packet_length;
}

int receive_data_packet(const int fd, char **file_data,
		size_t received_file_bytes, size_t* sequence_number)
{
	byte *data_packet;
	int data_packet_length = 0;

	if ((data_packet_length = llread(fd, &data_packet)) < 0) {
		return -1;
	}

#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, "receive_data_packet()\n");
	fprintf(stderr, "\treceived_data_bytes=%d\n", data_packet_length);
#endif

	byte control_field = data_packet[control_field_index];
	if (control_field == control_field_data) {
#ifdef APPLICATION_LAYER_DEBUG_MODE
		fprintf(stderr, "\tdata packet\n");
#endif

		return parse_data_packet(data_packet_length, data_packet, file_data,
				sequence_number);
	} else if (control_field == control_field_end) {
#ifdef APPLICATION_LAYER_DEBUG_MODE
		fprintf(stderr, "\tend control packet\n");
#endif
		char* file_name;
		size_t file_size;
		if (parse_control_packet(data_packet_length, data_packet, &file_name,
				&file_size) == 0) {
			return 0;
		} else {
			return -1;
		}
	}

	fprintf(stderr, "receive_data_packet(): bad control field value\n");
	free(data_packet);
	return -1;
}

int llopen(char *port, int transmitter)
{
	struct connection conn;
	strcpy(conn.port, port);
	conn.frame_size = FRAME_SIZE;
	conn.micro_timeout_ds = MICRO_TIMEOUT_DS;
	conn.timeout_s = TIMEOUT_S;
	conn.num_retransmissions = NUM_RETRANSMISSIONS;
	conn.close_wait_time = CLOSE_WAIT_TIME;
	conn.packet_size = FRAME_SIZE;

	if ((conn.is_transmitter = transmitter)) {
		if (transmitter_connect(&conn) < 0) {
			return -1;
		}
	} else {
		if (receiver_listen(&conn)) {
			return -1;
		}
	}

	g_connections[conn.fd] = conn;
	return conn.fd;
}

void print_status(time_t t0, size_t num_bytes, unsigned long counter)
{
	double dt = difftime(time(NULL ), t0);
	double speed = ((double) (num_bytes * 8)) / dt;
	fprintf(stderr, "----------------------\n");
	fprintf(stderr,
			"Link layer transmission %ld: %lf bit per sec; %ldB of data\n",
			counter, speed, num_bytes);
	fprintf(stderr, "----------------------\n");
}

int llclose(const int fd)
{
	return disconnect(&g_connections[fd]);
}

void receiver_stats()
{
	fprintf(stdout, "Receiver statistics\n");
	fprintf(stdout, "\treceived file bytes/file bytes:%zu/%zu\n",
			received_file_bytes, real_file_bytes);
	fprintf(stdout, "\tlost packets:%zu\n", lost_packets);
	fprintf(stdout, "\tduplicated packets:%zu\n", duplicated_packets);
}

void retry(int* attempt)
{
	(*attempt)--;
	if (*attempt <= 0)
		return;
#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, "\tnew attempt in 5 seconds .");
#endif
	sleep(1);
#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, " .");
#endif
	sleep(1);
#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, " .");
#endif
	sleep(1);
#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, " .");
#endif
	sleep(1);
#ifdef APPLICATION_LAYER_DEBUG_MODE
	fprintf(stderr, " .\n");
#endif
	sleep(1);
}
\end{lstlisting}


\subsection{Camada de ligação de dados}
\subsubsection*{serial\_port.c}
\begin{lstlisting}[style=customcwithlines]
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <termios.h>
#include <stdio.h>
#include <strings.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

#include "netlink.h"
#include "serial_port.h"

typedef unsigned char byte;
int serial_port_baudrate = B19200;

#define _POSIX_SOURCE 1 /* POSIX compliant source */

struct termios g_oldtio;

byte g_previous_last_byte = 0;
byte serial_port_previous_last_byte()
{
	return g_previous_last_byte;
}

byte g_last_byte = 0;
byte serial_port_last_byte()
{
	return g_last_byte;
}

int serial_port_open(const char *dev_name, const int micro_timeout)
{
#ifdef SERIAL_PORT_DEBUG_MODE
	fprintf(stderr,"serial_port_open(): entering function; dev = %s\n, timeout = \
            %d\n",dev_name,micro_timeout);
#endif

	/*
	 Open serial port device for reading and writing and not as controlling
	 tty because we don't want to get killed if linenoise sends CTRL-C.
	 */
	int fd = -1;
	struct termios newtio;

	fd = open(dev_name, O_RDWR | O_NOCTTY);
	if (fd < 0) {
		perror(dev_name);
		return -1;
	}

#ifdef SERIAL_PORT_DEBUG_MODE
	fprintf(stderr,"isatty()=%d, ttyname()=%s\n",isatty(fd),ttyname(fd));
	fprintf(stderr,"fd = %d\n",fd);
#endif

	/* Port settings */
	if (tcgetattr(fd, &g_oldtio) == -1) { /* save current port settings */
		perror("tcgetattr");
		return -1;
	}

	bzero(&newtio, sizeof(newtio)); /* clear struct for new port settings */
	newtio.c_cflag = serial_port_baudrate | CS8 | CLOCAL | CREAD;
	newtio.c_iflag = IGNPAR;
	newtio.c_oflag = 0;
	newtio.c_lflag = 0;

	/* 0 => inter-character timer unused */
	newtio.c_cc[VTIME] = micro_timeout;

	/* VMIN=1 => blocking read until 1 character is received */
	//newtio.c_cc[VMIN] = (micro_timeout == 0) ? 1 : 0;
	newtio.c_cc[VMIN] = 1;

#ifdef SERIAL_PORT_DEBUG_MODE
	fprintf(stderr,"serial_port_open(): timeout=%d, c_cc[VMIN]=%d\n",micro_timeout,
			newtio.c_cc[VMIN]);
#endif

	tcflush(fd, TCIFLUSH);
	if (tcsetattr(fd, TCSANOW, &newtio) == -1) {
		perror("tcsetattr");
		exit(-1);
	}
	return fd;
}

int serial_port_close(int fd, int close_wait_time)
{
#ifdef SERIAL_PORT_DEBUG_MODE
	fprintf(stderr,"serial_port_close(): waiting %d seconds to close...\n",
			close_wait_time);
#endif
	sleep(close_wait_time);

	int ret = tcsetattr(fd, TCSANOW, &g_oldtio);
	if (ret == -1) {
		perror("tcsetattr");
		return -1;
	}
	return close(fd);
}

int serial_port_write(int fd, byte *data, int len)
{
#ifdef SERIAL_PORT_DEBUG_MODE
	fprintf(stderr,"serial_port_write(): writting: length = %d, fd = %d\n",len,fd);
#endif

    //fprintf(stderr,"write\n");
	int result = write(fd, data, len);

	if (result < 0) {
		fprintf(stderr, "serial_port_write(): error %d, errno = %x\n", result,
				errno);
#ifdef SERIAL_PORT_DEBUG_MODE
	} else {
		fprintf(stderr,"serial_port_write(): wrote %d bytes\n",result);
#endif
	}

	return result;
}

/** \brief Read from serial port until either:
 * - a delimiter char is found
 * - the maximum number of chars is read 
 * - there is a timeout
 *
 * @return Number of chars read or negative number if error
 * */
int serial_port_read(int fd, byte *data, byte delim, int maxc)
{
#ifdef SERIAL_PORT_DEBUG_MODE
	fprintf(stderr,"serial_port_read(): entering function\n");
	fprintf(stderr,"                    delimiter = %x\n",(char)delim);
#endif

	g_previous_last_byte = g_last_byte;

    //fprintf(stderr,"read\n");
	byte *p = data;
	int nc = 0; // num chars read so far
	do {
		int ret = read(fd, &g_last_byte, 1);
		if (ret == 0) {
#ifdef SERIAL_PORT_DEBUG_MODE
			fprintf(stderr,"serial_port_read(): micro timeout tick\n");
#endif
			break;
		} else if (ret < 0 && errno == EINTR) { // interrupted, possibly by an alarm
#ifdef SERIAL_PORT_DEBUG_MODE
		fprintf(stderr,"serial_port_read(): received interrupt\n");
#endif
			return 0;
		} else if (ret < 0) {
#ifdef SERIAL_PORT_DEBUG_MODE
			fprintf(stderr,"serial_port_read(): ret = %d, errno = %d\n",ret,errno);
#endif
		}
#ifdef SERIAL_PORT_PRINT_ALL_CHARS
		fprintf(stderr,"< %x\n",g_last_byte);
		//fprintf(stderr,"c: %d/%c, nc: %d, ret: %d\n",c,c,nc,ret);
#endif

		*p++ = g_last_byte;
		nc++;
	} while (nc < maxc && g_last_byte != delim);

#ifdef SERIAL_PORT_DEBUG_MODE
	//fprintf(stderr,"serial_port_read(): read (%d): %.*s\n",nc,nc,data);
#endif

	return nc;
}
\end{lstlisting}

\subsubsection*{data\_link.c}
\begin{lstlisting}[style=customcwithlines]
#include <stdio.h>

#include "serial_port.h"
#include "data_link.h"
#include "data_link_codes.h"
#include "data_link_io.h"
#include <string.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

static long g_use_limited_rejected_retries = 1; // true or false

byte data_reply_byte(unsigned long frame_number, int accepted)
{
	return (accepted ? C_RR : C_REJ) | ((frame_number % 2) ? 0 : (1 << 7));
}

byte data_control_byte(unsigned long frame_number)
{
	return (frame_number % 2 == 0) ? 0 : (1 << 6);
}

static int handle_disconnect(struct connection* conn)
{
	int ret = 0;

	int ntries = conn->num_retransmissions;
	while (1) {
		struct frame reply;
		if ((ntries = f_send_acknowledged_frame(conn->fd, ntries,
				conn->timeout_s, DISC, &reply)) < 0) {
			ret = -1;
			break;
		}
		if (reply.control == C_UA) {
			break;
		}
	}

	conn->is_active = 0;
	if (serial_port_close(conn->fd, 0) < 0 || ret < 0) {
		return -1;
	}
	return 0;
}

/*
 * TRANSMITTER
 */

/** \brief Establish logical connection.
 *
 * Open serial port, send SET, receive UA. */
int transmitter_connect(struct connection* conn)
{
	conn->is_active = 0;
	conn->max_buffer_size = LL_MAX_PAYLOAD_STUFFED;
	conn->frame_number = 0;

	if ((conn->fd = serial_port_open(conn->port, conn->micro_timeout_ds)) < 0) {
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,
				"transmitter_connect(): could not open %s\n",conn->port);
#endif
		return conn->fd;
	}

	/* Send SET frame and receive UA.  */
	int ntries = conn->num_retransmissions;
	while (1) {
		struct frame reply;
		if ((ntries = f_send_acknowledged_frame(conn->fd, ntries,
				conn->timeout_s, SET, &reply)) < 0) {
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"transmitter_connect(): no connection.\n");
#endif
			return -1;
		}

		if (reply.control == C_UA) {
			break;
		}
	}

	conn->is_active = 1;
#ifdef DATA_LINK_DEBUG_MODE
	fprintf(stderr,"Connection established.\n");
#endif
	return 0;
}

int transmitter_write(struct connection* conn, byte* data_packet, size_t size)
{
	fprintf(stderr," #-#################################### \n");
	fprintf(stderr,"\n");
	fprintf(stderr," BEGIN TRANSMIT %zu\n", conn->frame_number);
	fprintf(stderr,"\n");
	fprintf(stderr," ###################################### \n");

	struct frame out_frame = { .address = A, .control = data_control_byte(
			conn->frame_number), .size = size, .data = data_packet };

	byte success_rep = data_reply_byte(conn->frame_number, TRUE);
	byte rej_rep = data_reply_byte(conn->frame_number, FALSE);
    fprintf(stderr,"success_rep = %x\n",success_rep);
    fprintf(stderr,"rej_rep = %x\n",rej_rep);

	/* Send data frame and receive confirmation.  */
	int ntries = conn->num_retransmissions;
	while (1) {
		struct frame reply_frame;
        fprintf(stderr,"trying to send frame %lu\n",conn->frame_number);
		if ((ntries = f_send_acknowledged_frame(conn->fd, ntries,
				conn->timeout_s, out_frame, &reply_frame)) < 0) {
            fprintf(stderr,"failed acknowledged frame\n");
			return -1;
		}
        fprintf(stderr," ---- control = %x\n",reply_frame.control);
		if (reply_frame.control == rej_rep) {
            fprintf(stderr,"rejected frame\n");
			if (g_use_limited_rejected_retries) {
				--ntries;
			}
		}
		if (reply_frame.control == success_rep) {
            fprintf(stderr,"accepted frame\n");
			break;
		}
	}

	conn->frame_number++;
    fprintf(stderr,"new frame number: %zu\n",conn->frame_number);
	return 0;
}

/** \brief Establish logical connection.
 *
 * Open serial port, send SET, receive UA. */
int disconnect(struct connection* conn)
{
	int return_value = 0;

	/* Send DISC and receive DISC.  */
	int ntries = conn->num_retransmissions;
	while (1) {
		struct frame reply;
		if ((ntries = f_send_acknowledged_frame(conn->fd, ntries,
				conn->timeout_s, DISC, &reply)) < 0) {
			return_value = -1;
			break;
		}
		if (reply.control == C_DISC) {
			break;
		}
	}

	if (return_value >= 0) {
		if (f_send_frame(conn->fd, UA) != SUCCESS_CODE) {
			return_value = -1;
		}
	}

	conn->is_active = 0;

	// Close port
	if (serial_port_close(conn->fd, conn->close_wait_time) < 0) {
		return_value = -1;
	}

#ifdef DATA_LINK_DEBUG_MODE
	if (return_value < 0) {
		fprintf(stderr,"disconnect(): failed to close connection.\n");
	}
#endif
	return return_value;
}

/*
 * RECEIVER
 */

// TODO
int receiver_listen(struct connection* conn)
{
	conn->max_buffer_size = LL_MAX_PAYLOAD_STUFFED;
	conn->frame_number = 0;

	if ((conn->fd = serial_port_open(conn->port, conn->micro_timeout_ds)) < 0) {
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"listen(): could not open %s\n",conn->port);
#endif
		return conn->fd;
	}

	while (1) {
		struct frame in;
		if (f_receive_frame(conn->fd, &in, 0) == ERROR_CODE) {
			return -1;
		}
        fprintf(stderr,"receiver_listen: %x\n",in.control);
		if (in.control == C_SET) {
			f_send_frame(conn->fd, UA);
			conn->is_active = 1;
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"listen(): connection established.\n");
#endif
			return 0;
		}
	}
}

int receiver_read(struct connection* conn, byte *begin, size_t max_data_size,
		const int max_num_frames)
{
	int num_frames = 0;
	byte *p = begin;
	byte *end = begin + max_data_size;

	while (p < end && (num_frames < max_num_frames || max_num_frames == 0)) {
		fprintf(stderr," ###################################### \n");
		fprintf(stderr,"\n");
		fprintf(stderr," BEGIN RECEIVE %zu\n", conn->frame_number);
		fprintf(stderr,"\n");
		fprintf(stderr," ###################################### \n");

		struct frame in;
		in.data = p;
		in.max_data_size = end - p;
		Return_e ret = f_receive_frame(conn->fd, &in, 0);

		if (ret == ERROR_CODE) {
			return -1;
		} else if (ret == TIMEOUT_CODE) {
			break;
		} else if (ret == BADFRAME_CODE) {
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"receiver_read(): parsing: bad frame.\n");
#endif
			/*
			 * Send 'bad frame' acknowledgment.
			 */
			byte c_out = data_reply_byte(conn->frame_number, FALSE);
			if (f_send_frame(conn->fd, FRAME(c_out)) != SUCCESS_CODE) {
				break;
			}
		} else if (in.control == C_DISC) {
			handle_disconnect(conn);
			break;
		} else if (in.control != data_control_byte(conn->frame_number)) {
			/*
			 * Frame number mismatch.
			 */
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"receiver_read(): bad control byte.\n");
			fprintf(stderr,"receiver_read(): %x, %x.\n",
					in.control,data_control_byte(conn->frame_number));
#endif
			byte control = data_reply_byte(conn->frame_number, FALSE);
			// reject this frame
			if (f_send_frame(conn->fd, FRAME(control)) != SUCCESS_CODE) {
				break;
			}
		} else {
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"receiver_read(): received: \"%.*s\".\n",
					(int)in.size,p);
#endif

			num_frames++;
			p += in.size;

			byte control = data_reply_byte(conn->frame_number, TRUE);
			if (f_send_frame(conn->fd, FRAME(control)) != SUCCESS_CODE) {
				break;
			}
			conn->frame_number++;
            fprintf(stderr,"new frame number: %zu\n",conn->frame_number);
		}
	}
	return p - begin;
}

// TODO
int wait_for_disconnect(struct connection* conn, int timeout)
{
	while (1) {
		struct frame in;
		f_receive_frame(conn->fd, &in, 0);
		if (in.control == C_DISC) {
			return handle_disconnect(conn);
		} else {
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,
					"receiver_wait_disconnect(): frame ignored, C=%x.\n",
					in.control);
#endif
		}
	}
	return -1;
}

#if 0
// ------------------------

// Function to print the pack content
char* packet_content(const char* packet, const int size)
{
	const char *hex = "0123456789ABCDEF";
	char *content = (char *) malloc(sizeof(char) * (3 * size));
	char *pout = content;
	const char *pin = packet;

	int i;

	if (pout) {

		for (i = 0; i < size - 1; i++) {
			*pout++ = hex[(*pin>>4)&0xF];
			*pout++ = hex[(*pin++)&0xF];
			*pout++ = ':';
		}
		*pout++ = hex[(*pin>>4)&0xF];
		*pout++ = hex[(*pin++)&0xF];
		*pout = 0;
	}

	return content;
}
#endif
\end{lstlisting}

\subsubsection*{data\_link\_io.c}
\begin{lstlisting}[style=customcwithlines]
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>

#include "serial_port.h"
#include "data_link.h"
#include "data_link_io.h"
#include "data_link_codes.h"
#include "byte.h"

volatile int g_timeout_alarm = 0;
void set_timeout_alarm()
{
	g_timeout_alarm = 1;
}

static byte g_buffer[LL_MAX_FRAME_SZ]; /** Local array for frame building. */
static long g_sent_frame_counter = 0;
static long g_rec_frame_counter = 0;
static long g_header_bcc_error_counter = 0;
static long g_data_bcc_error_counter = 0;

struct frame FRAME(const byte control)
{
	struct frame super = { .address = A, .control = control, .size = 0 };
	return super;
}

void f_print_frame(const struct frame frame)
{
	fprintf(stderr, "Frame:\n");
	fprintf(stderr, "A:%o C:%o S:%zu\n", frame.address, frame.control,
			frame.size);
	if (frame.size > 0) {
		for (int i = 0; i < frame.size; i++) {
			putc(frame.data[i], stderr);
		}
		putc('\n', stderr);
	}
	putc('\n', stderr);
}

void f_dump_frame_buffer(const char *filename)
{
	FILE* f;
	if ((f = fopen(filename, "w")) == NULL ) {
		fprintf(stderr, "f_dump_frame_buffer(): file error: line: %d\n",
				__LINE__);
	} else if (fprintf(f, "%.*s", LL_MAX_FRAME_SZ, g_buffer) < 0) {
		fprintf(stderr, "f_dump_frame_buffer(): file error: line: %d\n",
				__LINE__);
	} else if (fclose(f) == EOF) {
		fprintf(stderr, "f_dump_frame_buffer(): file error: line: %d\n",
				__LINE__);
	}
}

/* Reads array and builds a "struct Frame* frame*" from it
 * - checks if its a supervision or data frame
 * - checks bcc 
 * - destuffs bytes
netlink.c * - returns SUCCESS_CODE, ERROR_CODE, or BADFRAME_CODE (when bcc is wrong, or
 *   data is too large)
 */
static Return_e parse_frame_from_array(struct frame* frame, byte *a)
{
#ifdef DATA_LINK_DEBUG_MODE
	fprintf(stderr,"  parse_frame_from_array(): entering function.\n");
	//f_dump_frame_buffer("FRAME");
#endif

	if (*a++ != FLAG) {
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"  parse_frame_from_array(): error: missing flag: \
                (line %d).\n",__LINE__);
#endif
		return ERROR_CODE;
	}
	for (int i = 0; i <= 2; i++) { // the next fields should not have a FLAG
		if (a[i] == FLAG) {
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"  parse_frame_from_array(): error: unexpected flag \
                    (line %d).\n",__LINE__);
#endif
			return BADFRAME_CODE;
		}
	}

	frame->address = *a++;
	frame->control = *a++;
	const byte header_bcc = *a++;
	if (header_bcc != (frame->address ^ frame->control)) {
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"  parse_frame_from_array(): error: header bcc: %d.\n",__LINE__);
#endif
		++g_header_bcc_error_counter;
		return BADFRAME_CODE;
	}
	frame->size = 0;

	/* Supervision frame */
	if (*a == FLAG) {
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"  parse_frame_from_array(): read a supervision frame.\n");
#endif
		return SUCCESS_CODE;
	}

	if (*(a + 1) == FLAG) {
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"  parse_frame_from_array(): error: only 1B remaining.\n");
#endif
		return BADFRAME_CODE;
	}

	/* Data frame */
	byte data_bcc = 0;
	size_t num_bytes = 0;
	while (1) {
		if (num_bytes > LL_MAX_PAYLOAD_STUFFED) {
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"  parse_frame_from_array(): line %d.\n",__LINE__);
#endif
			return BADFRAME_CODE;
		}
		if (frame->size > frame->max_data_size) {
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"  parse_frame_from_array(): line %d.\n",__LINE__);
#endif
			return BADFRAME_CODE;
		}

		byte c;
		if (a[num_bytes] == BS_ESC) {
			fprintf(stderr, "----\n");
			// remove byte stuffing
			++num_bytes;
			c = BS_OCT ^ a[num_bytes];
		} else {
			c = a[num_bytes];
		}
        ++num_bytes;
        frame->data[frame->size++] = c;
        fprintf(stderr, "%x\n", c);

		/*
		 * Stop loop condition.
		 */
		if (a[num_bytes] == FLAG) {
			if (frame->data[frame->size-1] != data_bcc) {
				++g_data_bcc_error_counter;
#ifdef DATA_LINK_DEBUG_MODE
				fprintf(stderr,"parse_frame_from_array(): data bcc error: line %d.\n",__LINE__);
				fprintf(stderr, "frame size %ld\n", frame->size);
				fprintf(stderr, "data bcc = %x\n", data_bcc);
				fprintf(stderr, "a[num_bytes-1] = %x\n", a[num_bytes-1]);
#endif
				return BADFRAME_CODE;
			}
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"  parse_frame_from_array(): successful read.\n");
#endif
			return SUCCESS_CODE;
		} else {
            data_bcc ^= c;
            fprintf(stderr,"c = %x, bcc = %x\n",c,data_bcc);
        }

	}
}

static byte *
copy_and_stuff_bytes(byte *dest, const byte *src, const size_t src_size)
{
	int bcc = 0;
	for (int i = 0; i <= src_size; ++i) {
        byte c;
        if (i != src_size) {
            c = src[i];
            bcc ^= c;
            fprintf(stderr,"c = %x, bcc = %x\n",c,bcc);
            //fprintf(stderr, "%2x\n", c);
        } else {
            fprintf(stderr,"bcc = %x\n",bcc);
            c = bcc;
        }
		if (c == FLAG || c == BS_ESC) {
			*dest++ = BS_ESC;
			*dest++ = BS_OCT ^ c;
		} else {
			*dest++ = c;
		}
	}
	fprintf(stderr, "size %ld (not counting bcc)\n", src_size);
	return dest;
}

/** \brief Send any type of frame.
 *
 * Compose a g_buffer[] array from a Frame and send it to the serial port.
 *
 * @return ERROR_CODE or ERROR_SUCCESS.
 */
Return_e f_send_frame(const int fd, const struct frame frame)
{
#ifdef DATA_LINK_DEBUG_MODE
	fprintf(stderr,"f_send_frame(): beginning frame writing (C=0x%2x, %zu bytes)\n",
			frame.control,frame.size);
#endif

	byte *bp = g_buffer;

	*bp++ = FLAG;

	// write header
	*bp++ = frame.address;
	*bp++ = frame.control;
	*bp++ = frame.address ^ frame.control; // bcc

	// copy data
	if (frame.size > LL_MAX_PAYLOAD_UNSTUFFED) {
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"f_send_frame(): tried to send too big a frame \
                (%zu bytes)\n",frame.size);
#endif
		return ERROR_CODE;

	} else if (frame.size > 0) { // frame might be 0 if it is supervision
		bp = copy_and_stuff_bytes(bp, frame.data, frame.size);
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"f_send_frame(): unstuffed data size %ld.\n",frame.size);
#endif
	}

	*bp++ = FLAG;

	if (serial_port_write(fd, g_buffer, bp - g_buffer) < 0) {
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"f_send_frame(): writting failed.\n");
#endif
		return ERROR_CODE;
	}
	++g_sent_frame_counter;
#ifdef DATA_LINK_DEBUG_MODE
	fprintf(stderr,"f_send_frame(): finished sending frame #%ld\n",
			g_sent_frame_counter);
#endif
	return SUCCESS_CODE;
}

void start_alarm(int s)
{
#ifdef DATA_LINK_DEBUG_MODE
	fprintf(stderr,"Setting alarm: %d sec.\n",s);
#endif
	signal(SIGALRM, set_timeout_alarm);  // TODO: put in init function
	g_timeout_alarm = 0;
	alarm(s);
}

/** 
 */
Return_e f_receive_frame(const int fd, struct frame* frame, const int timeout_s)
{
#ifdef DATA_LINK_DEBUG_MODE
	fprintf(stderr,"  f_receive_frame(): beginning frame reception.\n");
#endif

	const int using_timeout = (timeout_s > 0);

	if (using_timeout) {
		start_alarm(timeout_s);
	}
	while (1) {
		while (serial_port_last_byte() != FLAG) { // first flag
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"  f_receive_frame(): looking for next flag.\n");
#endif

			if (serial_port_read(fd, g_buffer, FLAG, LL_MAX_FRAME_SZ) < 0) {
				return ERROR_CODE;
			}
			if (using_timeout && g_timeout_alarm) {
				return TIMEOUT_CODE;
			}

#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"  f_receive_frame(): last byte=%x.\n",
					serial_port_last_byte());
#endif
		}
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"  f_receive_frame(): First FLAG detected.\n");
#endif
		g_buffer[0] = FLAG;

		// skip initial flags and read
		while (1) {
			if (using_timeout) {
				start_alarm(timeout_s);
			}
			int ret = serial_port_read(fd, g_buffer + 1, FLAG,
					LL_MAX_FRAME_SZ - 1);
			if (using_timeout && g_timeout_alarm) {
				return TIMEOUT_CODE;
			}
			if (ret < 0) {
				fprintf(stderr, "  f_receive_frame(): error.\n");
				return -1;
			}
			if (ret > 1) {
				break;
			}
		}

		if (serial_port_last_byte() == FLAG) { // final flag
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"  f_receive_frame(): Last FLAG detected.\n");
#endif
			Return_e ret = parse_frame_from_array(frame, g_buffer);
			if (ret == SUCCESS_CODE) {
				++g_rec_frame_counter;
			}
            else if (ret == BADFRAME_CODE) {
                fprintf(stderr,"bad frame detected while parsing\n");
            }
			return ret;
		}
		if (using_timeout && g_timeout_alarm) {
			return TIMEOUT_CODE;
		}
	}
}

/** Sends 'frame' and gets reply. */
int f_send_acknowledged_frame(const int fd, const unsigned num_retransmissions,
		const int timeout_s, struct frame out_frame, struct frame *reply)
{
	int ntries = (num_retransmissions <= 0) ? -1 : num_retransmissions;

	while (ntries > 0) {
#ifdef DATA_LINK_DEBUG_MODE
		fprintf(stderr,"f_send_acknowledged_frame(): ntries = %d.\n",ntries);
#endif

		if (f_send_frame(fd, out_frame) == ERROR_CODE) {
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"f_send_acknowledged_frame(): error writting\n");
#endif
			return -1;
		}

		reply->control = 0;
		Return_e ret = f_receive_frame(fd, reply, timeout_s);

		if (ret == ERROR_CODE) {
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"f_send_acknowledged_frame(): error reading\n");
#endif
			return -1;
		} else if (ret == TIMEOUT_CODE) {
#ifdef DATA_LINK_DEBUG_MODE
			fprintf(stderr,"f_send_acknowledged_frame(): timeout\n");
#endif
			--ntries;
			continue;
		} else if (ret == BADFRAME_CODE) {     // reset number of attempts
#ifdef DATA_LINK_DEBUG_MODE
				fprintf(stderr,"f_send_acknowledged_frame(): bad frame\n");
#endif
			ntries--;
			continue;
        } else if ((reply->control & 7) == C_REJ) {
            fprintf(stderr,"detected rejected frame while parsing\n");
            ntries--;
		} else {
			break;
		}
	}

	return ntries;
}
\end{lstlisting}

\subsection{Ficheiros com funções de validação}
\subsubsection*{data\_link\_test.c}
\begin{lstlisting}[style=customcwithlines]
#include "data_link_codes.h"
#include "data_link_io.h"
#include "data_link.h"
#include "serial_port.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <termios.h> // Baudrate
#define DEVICE "/dev/ttyS0"

int TRANSMITTER = 0;

struct connection CONNECTION = { .max_buffer_size = LL_MAX_PAYLOAD_STUFFED,
		.num_retransmissions = 3, .baudrate = B300, .timeout_s = 3,
		.micro_timeout_ds = 11, .close_wait_time = 3 };

int are_frames_equal(struct frame f1, struct frame f2)
{
	if (f1.address != f2.address) {
		fprintf(stderr, "are_frames_equal(): %d\n", __LINE__);
		return 0;
	}
	if (f1.control != f2.control) {
		fprintf(stderr, "are_frames_equal(): %d\n", __LINE__);
		return 0;
	}
	if (f1.size != f2.size) {
		fprintf(stderr, "are_frames_equal(): %d\n", __LINE__);
		return 0;
	}
	for (size_t i = 0; i < f1.size; i++) {
		if (f1.data[i] != f2.data[i]) {
			fprintf(stderr, "are_frames_equal(): %d\n", __LINE__);
			return 0;
		}
	}
	return 1;
}

// Print how the arguments must be
void help(char **argv)
{
	printf("Usage: %s [OPTION] <serial port>\n", argv[0]);
	printf("\n Program options:\n");
	printf("  -t         transmit data over the serial port\n");
}

// Verifies serial port argument
int parse_serial_port_arg(int index, char **argv)
{
	char *dev = argv[index];
	if ((strcmp("/dev/ttyS0", dev) != 0) && (strcmp("/dev/ttyS1", dev) != 0)
			&& (strcmp("/dev/ttyS4", dev) != 0)) {
		return -3;
	}
	return index;
}

// Verifies arguments
int parse_args(int argc, char **argv)
{
	if (argc < 2)
		return -1;

	if (argc == 2)
		return parse_serial_port_arg(1, argv);

	if (argc == 3) {
		if ((strcmp("-t", argv[1]) != 0))
			return -2;
		else
			TRANSMITTER = 1;

		return parse_serial_port_arg(2, argv);
	} else
		return -1;
}

int test_1(struct connection* conn)
{
	if (TRANSMITTER) {
		f_print_frame(SET);
		if (f_send_frame(conn->fd, SET) != SUCCESS_CODE) {
			f_dump_frame_buffer("FRAME");
			printf("line: %d\n", __LINE__);
			return 1;
		}

	} else {

		struct frame frame;
		Return_e ret = f_receive_frame(conn->fd, &frame, 0);
		f_print_frame(frame);
		f_print_frame(SET);
		f_dump_frame_buffer("FRAME");

		if (ret != SUCCESS_CODE) {
			printf("ret: %d\n", (int) ret);
			printf("line: %d\n", __LINE__);
			return 1;
		}
		if (!are_frames_equal(frame, SET)) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
	}
	return 0;
}

int test_2(struct connection* conn)
{
	if (TRANSMITTER) {
		sleep(1);

		f_print_frame(SET);
		struct frame reply;
		if (0 > f_send_acknowledged_frame(conn->fd, 1, 10, SET, &reply)) {
			printf("line: %d\n", __LINE__);
			return -1;
		}
		if (reply.control != C_UA) {
			f_dump_frame_buffer("FRAME");
			printf("line: %d\n", __LINE__);
			return -1;
		}
	} else {
		struct frame reply;
		Return_e ret = f_receive_frame(conn->fd, &reply, 30);
		if (ret == ERROR_CODE) {
			fprintf(stderr, "ret = %d\n", ret);
			printf("line: %d\n", __LINE__);
			return 1;
		}
		if (reply.control == C_SET) {
			f_send_frame(conn->fd, UA);
		}
	}
	return 0;
}

int test_3(struct connection* conn)
{
	int test_timeout_time = 3;

	if (TRANSMITTER) {
		f_print_frame(SET);
		f_dump_frame_buffer("FRAME");
		struct frame reply;
		if (0
				> f_send_acknowledged_frame(conn->fd, 3, test_timeout_time, SET,
						&reply)) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
		if (reply.control != C_UA) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
	} else {
		printf("Sleeping for %d seconds...", test_timeout_time + 1);
		sleep(test_timeout_time + 1); // force timeout

		struct frame reply;
		Return_e ret;

		ret = f_receive_frame(conn->fd, &reply, 3);
		if (ret == ERROR_CODE) {
			fprintf(stderr, "ret = %d\n", ret);
			printf("line: %d\n", __LINE__);
			return 1;
		}
		ret = f_receive_frame(conn->fd, &reply, 3);
		if (ret == ERROR_CODE) {
			fprintf(stderr, "ret = %d\n", ret);
			printf("line: %d\n", __LINE__);
			return 1;
		}
		if (reply.control == C_SET) {
			f_send_frame(conn->fd, UA);
		}
	}
	return 0;
}

int test_4(struct connection *conn)
{
	if (TRANSMITTER) {
		if (transmitter_connect(conn) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
		printf("Connection established.\n");
		if (disconnect(conn) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
	} else {
		if (receiver_listen(conn) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
		if (wait_for_disconnect(conn, 0) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
	}
	return 0;
}

int test_single_message(struct connection *conn, byte* data)
{
	if (TRANSMITTER) {
		if (transmitter_connect(conn) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}

		byte* s = data;
		if (transmitter_write(conn, s, strlen((char*) s) + 1) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
		printf("--- Transmitted: %s\n", (char*) s);

		if (disconnect(conn) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
	} else {
		if (receiver_listen(conn) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}

		byte dest[8000];

		if (receiver_read(conn, dest, 8000, 0) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
		printf("--- Received: %s\n", (char*) dest);
		if (strcmp((char*) dest, (char*) data) != 0) {
			printf("%s\n", (char*) dest);
			printf("%s\n", (char*) data);
			printf("line: %d\n", __LINE__);
			return 1;
		}
	}
	return 0;
}

int test_5(struct connection* conn)
{
	char *data = "isto e um teste";
	return test_single_message(conn, (byte*) data);
}

int test_6(struct connection* conn)
{
	char data[] = "Flag: x, Escape: x";
	data[6] = FLAG;
	data[17] = BS_ESC;
	return test_single_message(conn, (byte*) data);
}

int send_message(struct connection* conn, byte* s)
{
	int len = strlen((char*) s);
	if (len == 0) {
		len = 1;
	}
	if (transmitter_write(conn, s, len) < 0) {
		printf("line: %d\n", __LINE__);
		return 1;
	}
	printf("--- Transmitted: %s\n", (char*) s);
	return 0;
}

int test_7(struct connection* conn)
{
	char data1[] = "isto ";
	char data2[] = "e ";
	char data3[] = "um ";
	char data4[] = "teste ";
	char data5[] = "com ";
	char data6[] = "varias ";
	char data7[] = "tramas.";
	char data8[] = "";
	char final_string[] = "isto e um teste com varias tramas.";

	printf("data1 = %s\n", data1);

	if (TRANSMITTER) {
		if (transmitter_connect(conn) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
		send_message(conn, (byte*) data1);
		send_message(conn, (byte*) data2);
		send_message(conn, (byte*) data3);
		send_message(conn, (byte*) data4);
		send_message(conn, (byte*) data5);
		send_message(conn, (byte*) data6);
		send_message(conn, (byte*) data7);
		send_message(conn, (byte*) data8);

		if (disconnect(conn) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
	} else {
		if (receiver_listen(conn) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}

		byte dest[8000];

		if (receiver_read(conn, dest, 8000, 0) < 0) {
			printf("line: %d\n", __LINE__);
			return 1;
		}
		printf("--- Received: %s\n", (char*) dest);
		if (strcmp((char*) dest, final_string) != 0) {
			printf("%s\n", (char*) dest);
			printf("%s\n", final_string);
			printf("line: %d\n", __LINE__);
			return 1;
		}
	}
	return 0;
}

int main(int argc, char *argv[])
{
	int i;
	if ((i = parse_args(argc, argv)) < 0) {
		help(argv);
		printf("line: %d\n", __LINE__);
		return 1;
	}

	struct connection conn = CONNECTION;

	strcpy(conn.port, argv[i]);

	if ((conn.fd = serial_port_open(conn.port, conn.micro_timeout_ds)) < 0) {
		printf("line: %d\n", __LINE__);
		return 1;
	}
	assert(test_1(&conn) == 0);
	printf(" ------------ Passed test 1\n");
	assert(test_2(&conn) == 0);
	printf(" ------------ Passed test 2\n");
	assert(test_3(&conn) == 0);
	printf(" ------------ Passed test 3\n");
	if (serial_port_close(conn.fd, 3) < 0) {
		printf("line: %d\n", __LINE__);
		return 1;
	}

	assert(test_4(&conn) == 0);
	printf(" ------------ Passed test 4\n");
	assert(test_5(&conn) == 0);
	printf(" ------------ Passed test 5\n");
	assert(test_6(&conn) == 0);
	printf(" ------------ Passed test 6\n");
	assert(test_7(&conn) == 0);
	printf(" ------------ Passed test 7\n");
	printf("Finished\n");
	return 0;
}
\end{lstlisting}

\subsubsection*{serial\_port\_test.c}
\begin{lstlisting}[style=customcwithlines]
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>

#include "serial_port.h"
#include "data_link.h"
#include "byte.h"

#define FALSE 0
#define TRUE 1

#define BUFSIZE 4096

int is_transmitter = FALSE;

// Print how the arguments must be
void help(char **argv)
{
	printf("Usage: %s [OPTION] <serial port>\n", argv[0]);
	printf("\n Program options:\n");
	printf("  -t         transmit data over the serial port\n");
}

// Verifies serial port argument
int parse_serial_port_arg(int index, char **argv)
{
    char *dev = argv[index];
	if ( (strcmp("/dev/ttyS0", dev)!= 0) &&
		(strcmp("/dev/ttyS1", dev)!=0) && 
		(strcmp("/dev/ttyS4", dev)!=0) ) {
		return -3;
    }
	return index;
} 

// Verifies arguments
int parse_args(int argc, char **argv)
{
	if (argc < 2)
		return -1;
		
	if (argc == 2)
		return parse_serial_port_arg(1, argv);
		
	if (argc == 3) {
		if ( (strcmp("-t", argv[1]) != 0) )
			return -2;
		else is_transmitter = TRUE;
		
		return parse_serial_port_arg(2, argv);
	}
	else return -1;
}

int send_receive_test(char* port,byte* test_message)
{
    int timeout = 0;
    int fd = serial_port_open(port,timeout);
    if (fd < 0) {
        fprintf(stderr,"serial_port_test: serial_port_open returned %d\n",fd);
        printf("line: %d\n",__LINE__);
        return 1;
    }

    byte s[BUFSIZE];
    if (is_transmitter) {
        int len = strlen((char*)test_message);
        if (serial_port_write(fd,(byte*)test_message,len+1) < 0) {
            printf("line: %d\n",__LINE__);
            return 1;
        }
        printf("len = %d\n",len);
        //printf("Message sent: %s\n",s);

        byte s[BUFSIZE];
        for (int i=0; i < BUFSIZE; i++) {
            s[i] = 1;
        }
        int r = serial_port_read(fd,s,'\0',BUFSIZE);
        if (r <= 0) {
            printf("r = %d\n",r);
            printf("line: %d\n",__LINE__);
            return 1;
        }
        //printf("Message received: %s\n",s);

	if (strcmp((char*)test_message,(char*)s) != 0) {
        printf("r = %d\n",r);
		printf("Test failed\n");
        /*
        for (int i = 0; test_message[i] != '\0'; ++i) {
            if (test_message[i] != s[i]) {
                printf("test_message %x\n",test_message[i]);
                printf("s %x\n",s[i]);
            }
        }
        */
		return -1;
	}

    } else {
        if (serial_port_read(fd,s,'\0',BUFSIZE) < 0) {
            printf("line: %d\n",__LINE__);
            return 1;
        }
        //printf("Message received: %s\n",s);

        int len = strlen((char*)s);
        if (serial_port_write(fd,s,len+1) < 0) {
            printf("line: %d\n",__LINE__);
            return 1;
        }
        //printf("Message sent: %s\n",(char*)s);
    }

    if (serial_port_close(fd,3) < 0) {
        fprintf(stderr,"serial_port_test: serial_port_close returned \
                negative\n");
        printf("line: %d\n",__LINE__);
        return 1;
    }
    return 0;
}


int test1(int argc,char **argv)
{
     // Verifies arguments
     int i = -1;
     if ( (i = parse_args(argc, argv)) < 0 ) {
     	help(argv);
             printf("line: %d\n",__LINE__);
     	return 1;
     }

    if (send_receive_test(argv[i],(byte*)"Um pequeno passo para o homem...") == 0) {
        printf("Test 1 passed\n");
    }
    return 0;
}

int get_frame(byte *dest,byte *src,byte flag)
{
    for (int i = 0; i < BUFSIZE; i++) {
        if (src[i] == flag) {
            dest[i] = '\0';
            return i;
        }
        dest[i] = src[i];
    }
    return -1;
}

int test2(int argc,char **argv)
{
    // Verifies arguments
    int i = -1;
    if ((i = parse_args(argc, argv)) < 0 ) {
        help(argv);
        printf("line: %d\n",__LINE__);
       return 1;
    }
	
    int timeout = 0;
    int fd = serial_port_open(argv[i],timeout);
    if (fd < 0) {
        fprintf(stderr,"serial_port_test: serial_port_open returned %d\n",fd);
        printf("line: %d\n",__LINE__);
        return 1;
    }


    if (is_transmitter) {
        byte *test_string = (byte*) "   F0001FF0002F0003F0004F  ";

        int len = strlen((char*)test_string);
        if (serial_port_write(fd,test_string,len+1) < 0) {
            printf("line: %d\n",__LINE__);
            return 1;
        }
    } else {
        // Read until first flag
        byte tmp[BUFSIZE];
        for (int i = 0; i < BUFSIZE; i++) { // init
            tmp[i] = 'x';
        }
        if (serial_port_read(fd,tmp,'F',BUFSIZE) < 0) {
            printf("line: %d\n",__LINE__);
            return 1;
        }

        byte dest[BUFSIZE];
        for (int i = 0; i < BUFSIZE; i++) { // init
            dest[i] = 'x';
        }

        byte *frames[] = 
        { (byte*)"0001", (byte*)"0002", (byte*)"0003", (byte*)"0004" };

        // Read a few frames
        for (int i = 0; i < 4; i++) {
            // Read a frame
            if (serial_port_read(fd,tmp,'F',BUFSIZE) < 0) {
                printf("line: %d\n",__LINE__);
                return 1;
            }

            byte plb = serial_port_previous_last_byte();
            printf("previous last byte: %c\n",plb);
            if (plb != 'F') {
                printf("line: %d\n",__LINE__);
                return 1;
            }

            int size = get_frame(dest,tmp,'F');
            if (size < 0) {
                printf("line: %d\n",__LINE__);
                return 1;
            } else if (size == 0) {
                // Space in between 'F's
                --i;
            } else {
                printf("frame %d: %s\n",i,(char*)dest);
                if (strcmp((char*)dest,(char*)frames[i]) != 0) {
                    printf("line: %d\n",__LINE__);
                    return 1;
                }
            }
        }
    }

    if (serial_port_close(fd,3) < 0) {
        fprintf(stderr,"serial_port_test: serial_port_close returned \
                negative\n");
        return 1;
    }

    printf("Test 2 passed\n");
    return 0;
}

int test3(int argc,char **argv)
{
    // Verifies arguments
    int i = -1;
    if ( (i = parse_args(argc, argv)) < 0 ) {
        help(argv);
        printf("line: %d\n",__LINE__);
        return 1;
    }

    byte message[256];
    for (int j = 0; j < 256; ++j) {
	    message[j] = j+1;
    }
    message[255] = '\0';
    //message[0] = 100;
    //message[1] = 101;
    //message[2] = 0;

    if (send_receive_test(argv[i],message) == 0) {
        printf("Test 3 passed\n");
    }
    return 0;
}

int main(int argc, char **argv)
{
    //printf("Test 1...\n");
    //assert(test1(argc,argv) == 0);

    //printf("Test 2...\n");
    //assert(test2(argc,argv) == 0);

    printf("Test 3...\n");
    assert(test3(argc,argv) == 0);
	return 0;
}
\end{lstlisting}

\end{document}

